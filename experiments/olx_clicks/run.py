""" Created at 11/04/2019@author: dimitris.michailidis"""import osfrom experiments.olx_clicks.args import Argsfrom experiments.parallel_trainer import ParallelTrainerfrom experiments.trainer import Trainerfrom helpers.dataset import Datasetfrom helpers.enums import LocationMode, ParallelMode, LatentModefrom helpers.model_loader import ModelLoaderfrom models.base_gru import SimpleGRUfrom models.city_gru import CityGRUfrom models.dist_gru import DistanceGRUfrom models.evaluation import Evaluationfrom models.latent_model import LatentGRUfrom models.lossfunction import LossFunctionfrom models.optimizer import Optimizerfrom models.parallel_model import ParallelModelif __name__ == '__main__':    args = Args()    model_loader = ModelLoader(args)    print("Loading train data from {}".format(os.path.join(args.data_folder, args.train_path)))    print("Loading validation data from {}".format(os.path.join(args.data_folder, args.valid_path)))    # print("Loading test data from {}\n".format(os.path.join(DATA_FOLDER, TEST_PATH)))    train_data = Dataset(os.path.join(args.data_folder, args.train_path))    # valid_data = Dataset(os.path.join(DATA_FOLDER, VALID_PATH), itemmap=train_data.itemmap)    valid_data = Dataset(os.path.join(args.data_folder, args.valid_path),                         itemmap=train_data.itemmap, citymap=train_data.citymap)    # initialize hyper-parameters    input_size = len(train_data.items)  # nr of unique items in the dataset    hidden_size = args.hidden_size    num_layers = args.num_layers    output_size = input_size    batch_size = args.batch_size    dropout_input = args.dropout_input    dropout_hidden = args.dropout_hidden    embedding_dim = args.embedding_dim    final_act = args.final_act    loss_type = args.loss_type    optimizer_type = args.optimizer_type    lr = args.lr    weight_decay = args.weight_decay    momentum = args.momentum    eps = args.eps    n_epochs = args.n_epochs    time_sort = args.time_sort    if not args.evaluate:        model_loader.initialize_model_checkpoint()        # Parallel Mode        if args.parallel_mode != ParallelMode.NONE:            if args.location_mode == LocationMode.DISTHOT or args.location_mode == LocationMode.DISTANCE:                location_model = DistanceGRU(input_size=input_size, hidden_size=hidden_size, output_size=output_size,                                             num_layers=num_layers, dropout_gru=dropout_hidden,                                             dropout_input=args.dropout_input, use_cuda=args.use_cuda,                                             batch_size=batch_size, parallel_mode=args.parallel_mode,                                             loc_mode=args.location_mode)            else:                city_size = len(train_data.cities)                distr_size = len(train_data.districts)                location_model = CityGRU(city_size=city_size, distr_size=distr_size, hidden_size=hidden_size,                                         output_size=output_size, num_layers=num_layers, dropout_gru=dropout_hidden,                                         dropout_input=args.dropout_input, use_cuda=args.use_cuda,                                         batch_size=batch_size,                                         parallel_mode=args.parallel_mode, location_mode=args.location_mode)            base_model = SimpleGRU(input_size=input_size, hidden_size=hidden_size, output_size=output_size,                                   num_layers=num_layers, dropout_gru=dropout_hidden, dropout_input=args.dropout_input,                                   use_cuda=args.use_cuda, batch_size=batch_size, embedding_dim=embedding_dim,                                   parallel_mode=args.parallel_mode, location_mode=args.location_mode)            parallel_model = ParallelModel(input_size=hidden_size, output_size=base_model.output_size,                                           use_cuda=args.use_cuda, parallel_mode=args.parallel_mode,                                           combination_mode=args.combination_mode)            base_optimizer = Optimizer(base_model.parameters(), optimizer_type=optimizer_type, lr=lr,                                       weight_decay=weight_decay,                                       momentum=momentum, eps=eps)            location_optimizer = Optimizer(location_model.parameters(), optimizer_type=optimizer_type, lr=lr,                                           weight_decay=weight_decay,                                           momentum=momentum, eps=eps)            parallel_optimizer = Optimizer(parallel_model.parameters(), optimizer_type=optimizer_type, lr=lr,                                           weight_decay=weight_decay, momentum=momentum, eps=eps)            loss_func = LossFunction(loss_type=loss_type, use_cuda=args.use_cuda)            parallel_trainer = ParallelTrainer(base_model, location_model, parallel_model, train_data=train_data,                                               eval_data=valid_data,                                               base_optim=base_optimizer, dist_optim=location_optimizer,                                               parallel_optim=parallel_optimizer,                                               use_cuda=args.use_cuda, loss_func=loss_func, args=args,                                               model_loader=model_loader)            parallel_trainer.train(start_epoch=0, end_epoch=n_epochs - 1)        else:            # Non-parallel mode            if args.latent_mode != LatentMode.NONE:                # latent mode                city_size = len(train_data.cities)                distr_size = len(train_data.districts)                model = LatentGRU(input_size=input_size, output_size=output_size, hidden_size=hidden_size,                                  num_layers=num_layers, dropout_gru=dropout_hidden, dropout_input=args.dropout_input,                                  use_cuda=args.use_cuda, batch_size=batch_size, latent_mode=args.latent_mode,                                  location_mode=args.location_mode, city_size=city_size, distr_size=distr_size,                                  context_size=args.context_size, embedding_dim=embedding_dim)            else:                if args.location_mode == LocationMode.DISTHOT or args.location_mode == LocationMode.DISTANCE:                    model = DistanceGRU(input_size=input_size, hidden_size=hidden_size, output_size=output_size,                                        num_layers=num_layers, dropout_gru=dropout_hidden,                                        dropout_input=args.dropout_input,                                        use_cuda=args.use_cuda, batch_size=batch_size, parallel_mode=args.parallel_mode,                                        loc_mode=args.location_mode)                elif args.location_mode == LocationMode.FULLCONCAT or args.location_mode == LocationMode.CITYHOT or \                        args.location_mode == LocationMode.DISTRICTHOT:                    input_size = len(train_data.cities)                    distr_size = len(train_data.districts)                    model = CityGRU(city_size=input_size, distr_size=distr_size,                                    hidden_size=hidden_size, output_size=output_size,                                    num_layers=num_layers, dropout_gru=dropout_hidden, dropout_input=args.dropout_input,                                    use_cuda=args.use_cuda, batch_size=batch_size, parallel_mode=args.parallel_mode,                                    location_mode=args.location_mode)                else:                    model = SimpleGRU(input_size=input_size, hidden_size=hidden_size, output_size=output_size,                                      num_layers=num_layers, dropout_gru=dropout_hidden,                                      dropout_input=args.dropout_input,                                      use_cuda=args.use_cuda, batch_size=batch_size, embedding_dim=embedding_dim,                                      parallel_mode=args.parallel_mode, location_mode=args.location_mode)            optimizer = Optimizer(model.parameters(), optimizer_type=optimizer_type, lr=lr, weight_decay=weight_decay,                                  momentum=momentum, eps=eps)            loss_func = LossFunction(loss_type=loss_type, use_cuda=args.use_cuda)            trainer = Trainer(model, train_data=train_data, eval_data=valid_data, optim=optimizer,                              use_cuda=args.use_cuda,                              loss_func=loss_func, args=args, model_loader=model_loader)            trainer.train(start_epoch=0, end_epoch=n_epochs - 1)    else:        # outdated        if args.pretrained_model_loc is not None:            model = model_loader.load_pretrained_model(args.pretrained_model_loc)            model.gru.flatten_parameters()            loss_function = LossFunction(loss_type=loss_type, use_cuda=args.use_cuda)            evaluation = Evaluation(model, loss_function, args.use_cuda, batch_size=args.batch_size,                                    location_mode=args.location_mode, k=args.topk, latent_mode=args.latent_mode)            loss, recall, mrr, recall5, mrr5, recall10, mrr10 = evaluation.eval(valid_data)            print("Final result: recall = {:.5f}, mrr = {:.5f}".format(recall, mrr))        else:            print("Pre trained model is None!")